#!/bin/bash
#
# Bash error library            @version: 1.0.0
# 
# This is an error handler for any kind of bash 
# script. The library catches defaults script errors
# as syntax erros by an trap and displays/logs them.
#
# All needed settings can be done in head of this file.
# It is also posible to export the vars in an external
# file, than you have to source them before this
# library.
#
# For more details read&visit 
# https://github.com/iptoux/bash_error_lib/wiki

############ LIBRARY VARIABLES ############

# Error
ERROR_EXIT=true
ERROR_LOG=true
ERROR_SRC_SNIPPED=true

# Debug
DEBUG_PID=$$
DEBUG_AUTO=false
DEBUG_OPT="-debug"

############ RUNTIME SETS ############ 
set +o errexit  # Deactivate default Exit after first command failure.
set -E

# DATE for log file names.
DATE=$(date +%m.%d.%y)

LOG_DIR=""
ERROR_FILE=${LOG_DIR}${DATE}'_error.log'
DEBUG_FILE=${LOG_DIR}${DATE}'_'${DEBUG_PID}'.log'

# Redirect stderr to file for parsing errors....
exec 2> 'stderr'

######################## BEGIN OF LIBRARY ########################
##################################################################
############ DONT ############ EDIT ############ HERE ############
##################################################################

############ HANDLER VARS/SETS ############
# Declaring all needed Container array's variables, lists
declare -A TARGS                                        # ARGS FROM TRAP
declare -gA FARGS                                       # ARGS FROME FILE
declare -gA ECONT                                       # CONTAINER ERROR VARIABLES (MERGE)
#declare -A eout
declare -A BECD                                          # CONTAINER ERROR VARIABLE CODE NAMES

ECD[1]="General/External script error."
ECD[2]="Bash script error."
ECD[126]="Command invoked cannot be exec."
ECD[127]="Command (func) not found."
ECD[128]="Invalid argument to exit."
ECD[130]="Script terminated by Control-C."




unset eout

# Bash error logging, the output printed in an error log file.
# This function builds the style of the log entry. Variables are stored
# global in eout[@]
bs_error_log() {

    # check if logging of errors in enabled.
    if [ "${ERROR_LOG}" == true ]; then

        # part of theme (line-split)
        lsp="##\n"

        # generate head
        emsg_head="\n#### + ${eout[0]} + ###################### ERROR ######################${lsp}"
        emsg_head+="${lsp}"
        
        # generate body
        emsg_body="##\tExitcode: ${eout[1]}\t\t|\tMsg:${eout[2]}\n"
        emsg_body+="${lsp}##\t>>>${eout[3]}\n"
        emsg_body+="${lsp}##\t------------------------------------------------------------\n"
        emsg_body+="${lsp}##\tCall from: ${eout[4]}\t\t|\tLine: ${eout[6]}\n"
        emsg_body+="${lsp}##\tFile: ${eout[5]}\n"

        # show source file output on failed line?
        # if yes, new split, else go to footer.

            if [ "${ERROR_SRC_SNIPPED}" == true ]; then
                # add output
                eded="${lsp}##\t------------------------------------------------------------\n"
                eded+="${lsp}##\t\t>>> 08 lines of source code (snipped) <<<\n"
                eded+="${lsp}## {\n"

                regfile=${eout[5]}

                regex=$(awk 'NR>L-5 && NR<L+5 { printf "##\tL:%-5d%3s%s\n",NR,(NR==L?">>>":""),$regfile }' L="${eout[6]}" "${eout[5]}")
                
                eded+="${regex}\n## }\n"

                emsg_body+="${eded}"
            fi

        # generate footer

        if [ "${ERROR_EXIT}" == false ] && [ "${eout[7]}" == false ]; then
            emsg_footer+="${lsp}################################################# SKIP ERROR #####${lsp}"    
            else
            emsg_footer+="${lsp}########################################################## EXIT #####${lsp}"
        fi

        # combine head+body+footer to one var
        emsg="${emsg_head}${emsg_body}${emsg_footer}"

        echo -e "${emsg}" >> "${ERROR_FILE}"
        return 0
    fi
}

bs_error_cli() {

    clierrout="\n------------------------------------------------\n"

    # Generate cli output, building head
    if ! [ -n "${eout[2]}" ]; then
            eout[2]=${eout[3]}
            clierrout+="\n>> ERROR (${eout[1]}) - ${ECD[2]}\n"
    else
        clierrout+="\n>> ERROR (${eout[1]}) - ${ECD[${eout[1]}]}\n"
    fi
    
    # Building body
    clierrout+=">> ->${eout[3]} <-\n"
    clierrout+="\n>> Caused by: ${eout[4]}\n"
    clierrout+=">> At file: ${eout[5]} on or near line ${eout[6]}\n"
    #clierrout+=">> In: ${eout[4]}\n"

    if  [ "${eout[7]}" == true ]; then
        clierrout+="\n>> Exit on error: (auto) default\n"
    else
        clierrout+="\n>> Exit on error: ${ERROR_EXIT}\n"
    fi

    clierrout+=">> Code-snipped: ${ERROR_SRC_SNIPPED}\n"

    # Check if file source snipped should be displayd
    if [ "${ERROR_SRC_SNIPPED}" == true ]; then
        if [ "${ERROR_EXIT}" == true ]; then

            clierrout+="\n------------------------------------------------\n"
            clierrout+="\n>> -> 08 lines of source from ${eout[5]} <-\n"
            
            clierrout+=">> {\n"

            regfile=${eout[5]}
            regex=$(awk 'NR>L-5 && NR<L+5 { printf "L:%-5d%3s%s\n",NR,(NR==L?">>>":""),$regfile }' L="${eout[6]}" "${eout[5]}")
                    
            clierrout+="${regex}\n>> }\n"
        else
            clierrout+="\nSet EXIT on Error to show!\n"
        fi
    fi

    # Actual push to stdrout
    echo -e "${clierrout}"

    return 0

}

# An simple function that handels the debug output.
# Checks if $SDEBUG is true. When @param "false" is
# given on call, you can disable debug mode on any file/line.
#
# @param bool "false"
bs_debug() {

    switch="${1}"

    if [ "${switch}" == "auto" ] || [ "${switch}" == true ]; then
        # open a new file descriptor for logging
        exec 5>> "${DEBUG_FILE}"
        # redirect trace logs to fd 5
        BASH_XTRACEFD=5
        # format output
        PS4='- [T]: $(date "+%H:%M:%S") [F]: $(basename ${BASH_SOURCE[0]}) [M]: ${FUNCNAME[0]} [L]: $LINENO [C]: '
        # activate debug to file
        set -o xtrace
    elif [ "$1" == false ]; then
        set +o xtrace
    fi

}


# Bash error library handler
# This is an own self written error handler, to handle function
# and command errors during the runtime/developemnt.
#
# It uses an typical trap, but can also display simple user
# error messages. These messages have to be piped.
# 
# Errors will logged in an file if enabled.
#
# @param $errmsg | @output err
bs_error() {

    # oldvars, needed?
    #err_time=$(date "+%H:%M:%S")

    declare -g rerun

    # get lenght of TARGS (for function name (4))
    TARGS_LEN=${#*}
    TARGS["code"]="${1}"

        # Check if script is called by default script 
        # exit (0) or error -> jump to cleanup if true
        if [[ ${TARGS["code"]} -eq 0 ]] || [[ ${rerun} -eq 1 ]]; then
            echo "Jumping to cleanUp!"
            unset rerun
            return 0
        fi

    TARGS["file"]="${2}"
    TARGS["line"]="${3}"
       
        # Check if lenght of args is 4 (function is given?)
        if [[ ${TARGS_LEN} -eq 4 ]]; then
            if [[ -z "$4" ]]; then
                TARGS["func"]="Script"
            else
                TARGS["func"]="${4}"
            
            fi
        else
            TARGS["func"]="N/A"
        fi

    # Load data from file
    error_read_file

    # Merge vars
    error_merge_vars

    # Generate and output msg
    error_out_msg

    # Display stack->trace
    error_stacktrace

    # don't re_run on script exit call
    rerun=1

    if [ "${ERROR_EXIT}" == true ]; then
        exit 1
    fi

}

bs_clean() {
    if [ -f 'stderr' ]; then
        rm 'stderr'
        return
    fi
    return 0
}


#### DONT #### EDIT #### DONT #### EDIT #### DONT #### EDIT #### DONT #### EDIT ##
## DONT #### EDIT #### DONT #### EDIT #### DONT #### EDIT #### DONT #### EDIT #### 
# DONT #### EDIT #### DONT #### EDIT #### DONT #### EDIT #### DONT #### EDIT ####  

# Checks if debug mode is set to auto enabled or if an
# command option (-youropt) is given on script call
if [ ${DEBUG_AUTO} == true ]; then    
    # call debug function
    bs_debug auto
else    
    # check if arg is DEBUG_OPT
    for i in "${@}"
    do 
        if [ "${i}" == "${DEBUG_OPT}" ];then    
        # call debug function
            bs_debug true
        fi
    done
    
fi