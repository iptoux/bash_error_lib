#!/bin/bash
#
# Bash error library            @version: 1.0.0
# 
# This is an error handler for any kind of bash 
# script. The library catches defaults script errors
# as syntax erros by an trap and displays/logs them.
#
# All needed settings can be done in head of this file.
# It is also posible to export the vars in an external
# file, than you have to source them before this
# library.
#
# For more details read&visit 
# https://github.com/iptoux/bash_error_lib/wiki

MTSTART=$(date +%s.%N)


############ LIBRARY VARIABLES ############

# Error
ERROR_EXIT=true
ERROR_LOG=true
ERROR_SRC_SNIPPED=true

# Debug
DEBUG_PID=$$
DEBUG_AUTO=false
DEBUG_OPT="-debug"

############ RUNTIME SETS ############ 
set +o errexit  # Deactivate default Exit after first command failure.
set -E


# DATE for log file names.
DATE=$(date +%m.%d.%y)

LOG_DIR="logs/"
ERROR_FILE=${LOG_DIR}${DATE}'_error.log'
DEBUG_FILE=${LOG_DIR}${DATE}'_'${DEBUG_PID}'.log'

# Redirect stderr to file for parsing errors....
exec 2> 'stderr'

######################## BEGIN OF LIBRARY ########################
##################################################################
############ DONT ############ EDIT ############ HERE ############
##################################################################

# Unsetting ARGS to start fresh
unset TARGS 
unset FARGS
unset ECONT

############ HANDLER VARS/SETS ############
# Declaring all needed Container array's variables, lists
declare -A TARGS                                        # ARGS FROM TRAP
declare -gA FARGS                                       # ARGS FROME FILE
declare -gA ECONT                                       # CONTAINER ERROR VARIABLES (MERGE)
declare -A BECD                                          # CONTAINER ERROR VARIABLE CODE NAMES

BECD[1]="General/External script error."
BECD[2]="Bash script error."
BECD[126]="Command invoked cannot be exec."
BECD[127]="Command (func) not found."
BECD[128]="Invalid argument to exit."
BECD[130]="Script terminated by Control-C."


# Bash error logging, the output printed in an error log file.
# This function builds the style of the log entry. Variables are stored
# global in eout[@]
bs_error_log() {

    # check if logging of errors in enabled.
    if [ "${ERROR_LOG}" == true ]; then

        # part of theme (line-split)
        lsp="##\n"

        # generate head
        emsg_head="\n#### + ${eout[0]} + ###################### ERROR ######################${lsp}"
        emsg_head+="${lsp}"
        
        # generate body
        emsg_body="##\tExitcode: ${eout[1]}\t\t|\tMsg:${eout[2]}\n"
        emsg_body+="${lsp}##\t>>>${eout[3]}\n"
        emsg_body+="${lsp}##\t------------------------------------------------------------\n"
        emsg_body+="${lsp}##\tCall from: ${eout[4]}\t\t|\tLine: ${eout[6]}\n"
        emsg_body+="${lsp}##\tFile: ${eout[5]}\n"

        # show source file output on failed line?
        # if yes, new split, else go to footer.

            if [ "${ERROR_SRC_SNIPPED}" == true ]; then
                # add output
                eded="${lsp}##\t------------------------------------------------------------\n"
                eded+="${lsp}##\t\t>>> 08 lines of source code (snipped) <<<\n"
                eded+="${lsp}## {\n"

                regfile=${eout[5]}

                regex=$(awk 'NR>L-5 && NR<L+5 { printf "##\tL:%-5d%3s%s\n",NR,(NR==L?">>>":""),$regfile }' L="${eout[6]}" "${eout[5]}")
                
                eded+="${regex}\n## }\n"

                emsg_body+="${eded}"
            fi

        # generate footer

        if [ "${ERROR_EXIT}" == false ] && [ "${eout[7]}" == false ]; then
            emsg_footer+="${lsp}################################################# SKIP ERROR #####${lsp}"    
            else
            emsg_footer+="${lsp}########################################################## EXIT #####${lsp}"
        fi

        # combine head+body+footer to one var
        emsg="${emsg_head}${emsg_body}${emsg_footer}"

        echo -e "${emsg}" >> "${ERROR_FILE}"
        return 0
    fi
}

bs_error_cli() {

    clierrout="\n------------------------------------------------\n"

    # Generate cli output, building head
    if ! [ -n "${eout[2]}" ]; then
            eout[2]=${eout[3]}
            clierrout+="\n>> ERROR (${eout[1]}) - ${ECD[2]}\n"
    else
        clierrout+="\n>> ERROR (${eout[1]}) - ${ECD[${eout[1]}]}\n"
    fi
    
    # Building body
    clierrout+=">> ->${eout[3]} <-\n"
    clierrout+="\n>> Caused by: ${eout[4]}\n"
    clierrout+=">> At file: ${eout[5]} on or near line ${eout[6]}\n"
    #clierrout+=">> In: ${eout[4]}\n"

    if  [ "${eout[7]}" == true ]; then
        clierrout+="\n>> Exit on error: (auto) default\n"
    else
        clierrout+="\n>> Exit on error: ${ERROR_EXIT}\n"
    fi

    clierrout+=">> Code-snipped: ${ERROR_SRC_SNIPPED}\n"

    # Check if file source snipped should be displayd
    if [ "${ERROR_SRC_SNIPPED}" == true ]; then
        if [ "${ERROR_EXIT}" == true ]; then

            clierrout+="\n------------------------------------------------\n"
            clierrout+="\n>> -> 08 lines of source from ${eout[5]} <-\n"
            
            clierrout+=">> {\n"

            regfile=${eout[5]}
            regex=$(awk 'NR>L-5 && NR<L+5 { printf "L:%-5d%3s%s\n",NR,(NR==L?">>>":""),$regfile }' L="${eout[6]}" "${eout[5]}")
                    
            clierrout+="${regex}\n>> }\n"
        else
            clierrout+="\nSet EXIT on Error to show!\n"
        fi
    fi

    # Actual push to stdrout
    echo -e "${clierrout}"

    return 0

}

# An simple function that handels the debug output.
# Checks if $SDEBUG is true. When @param "false" is
# given on call, you can disable debug mode on any file/line.
#
# @param bool "false"
bs_debug() {

    switch="${1}"

    if [ "${switch}" == "auto" ] || [ "${switch}" == true ]; then
        # open a new file descriptor for logging
        exec 5>> "${DEBUG_FILE}"
        # redirect trace logs to fd 5
        BASH_XTRACEFD=5
        # format output
        PS4='- [T]: $(date "+%H:%M:%S") [F]: $(basename ${BASH_SOURCE[0]}) [M]: ${FUNCNAME[0]} [L]: $LINENO [C]: '
        # activate debug to file
        set -o xtrace
    elif [ "$1" == false ]; then
        set +o xtrace
    fi

}


#### READ FROM FILE ###
#######################
#
# This function loads the erros information from external error file.
# After loading, the array lenght will be checked. This is needed to 
# get the all informations of an error, also if it is external.
error_read_file() {

    # Read content from file
    IFS=':' read -d '' -ra err_array < 'stderr'

        # 4 (internal) ->= default error message (with arg)
        #-> ./test.sh: line 75: lol: command not found         <- 
        #
        # 3 (external) ->= needs check, if trap gives needed vales.        
        #-> cat: lol: No such file or directory            <- 
        #        
        # 3 (internal) ->= default error message (without arg)
        #./test.sh: line 83: syntax error near unexpected token `}'
        if [[ ${#err_array[@]} -eq 5 ]]; then
            
            #echo "Multiline error/errors"
            FARGS["file"]=${err_array[0]}
            FARGS["line"]=${err_array[1]##* }
            FARGS["call"]=${err_array[4]//$'\n'/} # ${dt//$'\n'/} # Remove all newlines. ${dt%$'\n'}  # Remove a trailing newline. 
            FARGS["msg"]=$(echo "${err_array[2]}" | cut -d '.' -f1)
            # Add new line
            FARGS["msg"]="${FARGS["msg"]}
"
        elif [[ ${#err_array[@]} -eq 4 ]]; then
            # "Sinleline default (4) with argument/cmd"
            FARGS["file"]=${err_array[0]}
            FARGS["line"]=${err_array[1]##* }
            FARGS["call"]=${err_array[2]}
            FARGS["msg"]=${err_array[3]}
        elif [ -n "${err_array[1]##* }" ] && [ "${err_array[1]##* }" -eq "${err_array[1]##* }" ] 2>/dev/null; then
            if [[ ${#err_array[@]} -gt 5 ]]; then
                # "multiline args bigger than 5 / some external call"
                FARGS["file"]=${err_array[0]}
                FARGS["line"]=${err_array[1]##* }
                FARGS["call"]=${err_array[2]}
                FARGS["msg"]=$(echo "${err_array[3]}" | cut -d $'\n' -f1)
                FARGS["msg"]+="\n"

            else
                # "Singleline default (3) without argument/cmd"
                FARGS["file"]=${err_array[0]}
                FARGS["line"]=${err_array[1]##* }
                FARGS["msg"]=${err_array[2]}
            fi
        else
                echo "yes"
                # "Singleline default external error by internal call, no line, source, func."
                FARGS["file"]=${err_array[0]}
                FARGS["call"]=${err_array[1]}
                FARGS["msg"]=${err_array[2]}

                # this is an external error.
                declare -g isExt=true

        fi    

    #delete tmp_err file
    #rm 'stderr'
}

# Merge ARG VARS
#
# This function merges the VARS - TARGS & FARGS into an error conatiner var
# Check for empty args, check for matching lines
error_merge_vars(){

    #TARGS - CODE // FILE // LINE // FUNC
    #FARGS - FILE // LINE // CALL // MSG

    # FIll empty args with N/A
    if [[ -v "${FARGS["call"]}" ]]; then
        echo "Set"
        FARGS["call"]="N/A"
    fi

    # Fill container...
    ECONT["code"]="${TARGS["code"]}"

    ECONT["type"]="${BECD[${TARGS["code"]}]}"
    ECONT["msg"]="${FARGS["msg"]}"  #//\\n/
    
    
    # Check if it is an Syntax error and re-order vars
    # If true, we read from external error file.
    if [ "${FARGS["call"]}" == "syntax error" ]; then
        ECONT["call"]=" Script"
        ECONT["cause"]="${FARGS["call"]}"
    elif [ "${TARGS["func"]}" == "efile" ]; then
        ECONT["call"]="${FARGS["call"]}"
        ECONT["cause"]="Syntax error"
    else
        ECONT["call"]="${FARGS["call"]}"
        ECONT["cause"]="${TARGS["func"]}"
    fi
    
    ECONT["source"]="${TARGS["file"]}"
    
    # Match lines to get always the same
    if [[ "${TARGS["line"]}" -eq "${FARGS["line"]}" ]]; then
        ECONT["line"]="${TARGS["line"]}"
    else
        # Checks if FARGS-line is empty
        if [[ -z ${FARGS["line"]} ]]; then
            ECONT["line"]="${TARGS["line"]}"
        else
            ECONT["line"]="${FARGS["line"]}"
        fi
    fi
    
    # Check if is external command error
    if [ "${isExt}" == true ]; then
        ECONT["cause"]="${FARGS["file"]}"
    fi

    # done
    return 0
}

# This is the function to get and build stack
error_stacktrace() {
    
    #define local function vars
    local frame=1 LINE SUB FILE

    # loop through frames (func calls)
    while read -r LINE SUB FILE < <(caller "${frame}"); do
        printf '  %s @ %s:%s\n' "${SUB}" "${FILE}" "${LINE}"
        ((frame++))
    done
    
    echo ""
}


error_out_msg() {

    local prfx cli_out

    prfx=">> "

    cli_out="\n------------------------------------------------\n"

    cli_out+="${prfx}ERROR (${ECONT["code"]}) - ${ECONT["type"]}\n\n"
    cli_out+="${prfx}MSG:${ECONT["msg"]}"
    cli_out+="${prfx}CALL/CMD/ARG:${ECONT["call"]}\n\n"
    cli_out+="${prfx}CAUSE BY: ${ECONT["cause"]} IN: ${ECONT["source"]} ON LINE: ${ECONT["line"]}\n"
    cli_out+="${prfx}FULLSTACK:"

    echo -e "${cli_out}"
    
}

# Bash error library handler
# This is an own self written error handler, to handle function
# and command errors during the runtime/developemnt.
#
# It uses an typical trap, but can also display simple user
# error messages. These messages have to be piped.
# 
# Errors will logged in an file if enabled.
#
# @param $errmsg | @output err
bs_error_trap() {

    # oldvars, needed?
    #err_time=$(date "+%H:%M:%S")

    declare -g rerun

    # get lenght of TARGS (for function name (4))
    TARGS_LEN=${#*}
    TARGS["code"]="${1}"

        # Check if script is called by default script 
        # exit (0) or error -> jump to cleanup if true
        if [[ ${TARGS["code"]} -eq 0 ]] || [[ ${rerun} -eq 1 ]]; then
            unset rerun
            bs_clean
            return 0
        fi

    TARGS["file"]="${2}"
    TARGS["line"]="${3}"
       
        # Check if lenght of args is 4 (function is given?)
        if [[ ${TARGS_LEN} -eq 4 ]]; then
            if [[ -z "$4" ]]; then
                TARGS["func"]="Script"
            else
                TARGS["func"]="${4}"
            
            fi
        else
            TARGS["func"]="N/A"
        fi

    # Load data from file
    error_read_file

    # Merge vars
    error_merge_vars

    # Generate and output msg
    error_out_msg

    # Display stack->trace
    error_stacktrace

    # don't re_run on script exit call
    rerun=1

    if [ "${ERROR_EXIT}" == true ]; then
        exit 1
    fi

}

bs_clean() {

    local dur

    if [ -f 'stderr' ]; then
         rm 'stderr'
    fi
    
    dur=$(echo "$(date +%s.%N)"-"${MTSTART}" | node -p)
    printf ">> Execution time: %.6f seconds\n" "${dur}"
    return 0
}


#### DONT #### EDIT #### DONT #### EDIT #### DONT #### EDIT #### DONT #### EDIT ##
## DONT #### EDIT #### DONT #### EDIT #### DONT #### EDIT #### DONT #### EDIT #### 
# DONT #### EDIT #### DONT #### EDIT #### DONT #### EDIT #### DONT #### EDIT ####  

# Checks if debug mode is set to auto enabled or if an
# command option (-youropt) is given on script call
if [ ${DEBUG_AUTO} == true ]; then    
    # call debug function
    bs_debug auto
else    
    # check if arg is DEBUG_OPT
    for i in "${@}"
    do 
        if [ "${i}" == "${DEBUG_OPT}" ];then    
        # call debug function
            bs_debug true
        fi
    done
    
fi